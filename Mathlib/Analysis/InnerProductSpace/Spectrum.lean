/-
Copyright (c) 2021 Heather Macbeth. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Heather Macbeth
-/
import Mathlib.Analysis.InnerProductSpace.Rayleigh
import Mathlib.Analysis.InnerProductSpace.PiL2
import Mathlib.Algebra.DirectSum.Decomposition
import Mathlib.Order.CompleteLattice
import Mathlib.LinearAlgebra.Eigenspace.Minpoly
import Mathlib.Analysis.InnerProductSpace.Projection

#align_import analysis.inner_product_space.spectrum from "leanprover-community/mathlib"@"6b0169218d01f2837d79ea2784882009a0da1aa1"

/-! # Spectral theory of self-adjoint operators

This file covers the spectral theory of self-adjoint operators on an inner product space.

The first part of the file covers general properties, true without any condition on boundedness or
compactness of the operator or finite-dimensionality of the underlying space, notably:
* `LinearMap.IsSymmetric.conj_eigenvalue_eq_self`: the eigenvalues are real
* `LinearMap.IsSymmetric.orthogonalFamily_eigenspaces`: the eigenspaces are orthogonal
* `LinearMap.IsSymmetric.orthogonalComplement_iSup_eigenspaces`: the restriction of the operator to
  the mutual orthogonal complement of the eigenspaces has, itself, no eigenvectors

The second part of the file covers properties of self-adjoint operators in finite dimension.
Letting `T` be a self-adjoint operator on a finite-dimensional inner product space `T`,
* The definition `LinearMap.IsSymmetric.diagonalization` provides a linear isometry equivalence `E`
  to the direct sum of the eigenspaces of `T`.  The theorem
  `LinearMap.IsSymmetric.diagonalization_apply_self_apply` states that, when `T` is transferred via
  this equivalence to an operator on the direct sum, it acts diagonally.
* The definition `LinearMap.IsSymmetric.eigenvectorBasis` provides an orthonormal basis for `E`
  consisting of eigenvectors of `T`, with `LinearMap.IsSymmetric.eigenvalues` giving the
  corresponding list of eigenvalues, as real numbers.  The definition
  `LinearMap.IsSymmetric.eigenvectorBasis` gives the associated linear isometry equivalence
  from `E` to Euclidean space, and the theorem
  `LinearMap.IsSymmetric.eigenvectorBasis_apply_self_apply` states that, when `T` is
  transferred via this equivalence to an operator on Euclidean space, it acts diagonally.

These are forms of the *diagonalization theorem* for self-adjoint operators on finite-dimensional
inner product spaces.

## TODO

Spectral theory for compact self-adjoint operators, bounded self-adjoint operators.

## Tags

self-adjoint operator, spectral theorem, diagonalization theorem

-/


variable {ùïú : Type*} [RCLike ùïú]
variable {E : Type*} [NormedAddCommGroup E] [InnerProductSpace ùïú E]

local notation "‚ü™" x ", " y "‚ü´" => @inner ùïú E _ x y

open scoped ComplexConjugate

open Module.End

namespace LinearMap

namespace IsSymmetric

variable {T : E ‚Üí‚Çó[ùïú] E} (hT : T.IsSymmetric)

/-- A self-adjoint operator preserves orthogonal complements of its eigenspaces. -/
theorem invariant_orthogonalComplement_eigenspace (Œº : ùïú) (v : E) (hv : v ‚àà (eigenspace T Œº)·óÆ) :
    T v ‚àà (eigenspace T Œº)·óÆ := by
  intro w hw
  have : T w = (Œº : ùïú) ‚Ä¢ w := by rwa [mem_eigenspace_iff] at hw
  simp [‚Üê hT w, this, inner_smul_left, hv w hw]
#align linear_map.is_symmetric.invariant_orthogonal_eigenspace LinearMap.IsSymmetric.invariant_orthogonalComplement_eigenspace

/-- The eigenvalues of a self-adjoint operator are real. -/
theorem conj_eigenvalue_eq_self {Œº : ùïú} (hŒº : HasEigenvalue T Œº) : conj Œº = Œº := by
  obtain ‚ü®v, hv‚ÇÅ, hv‚ÇÇ‚ü© := hŒº.exists_hasEigenvector
  rw [mem_eigenspace_iff] at hv‚ÇÅ
  simpa [hv‚ÇÇ, inner_smul_left, inner_smul_right, hv‚ÇÅ] using hT v v
#align linear_map.is_symmetric.conj_eigenvalue_eq_self LinearMap.IsSymmetric.conj_eigenvalue_eq_self

/-- The eigenspaces of a self-adjoint operator are mutually orthogonal. -/
theorem orthogonalFamily_eigenspaces :
    OrthogonalFamily ùïú (fun Œº => eigenspace T Œº) fun Œº => (eigenspace T Œº).subtype‚Çó·µ¢ := by
  rintro Œº ŒΩ hŒºŒΩ ‚ü®v, hv‚ü© ‚ü®w, hw‚ü©
  by_cases hv' : v = 0
  ¬∑ simp [hv']
  have H := hT.conj_eigenvalue_eq_self (hasEigenvalue_of_hasEigenvector ‚ü®hv, hv'‚ü©)
  rw [mem_eigenspace_iff] at hv hw
  refine Or.resolve_left ?_ hŒºŒΩ.symm
  simpa [inner_smul_left, inner_smul_right, hv, hw, H] using (hT v w).symm
#align linear_map.is_symmetric.orthogonal_family_eigenspaces LinearMap.IsSymmetric.orthogonalFamily_eigenspaces

theorem orthogonalFamily_eigenspaces' :
    OrthogonalFamily ùïú (fun Œº : Eigenvalues T => eigenspace T Œº) fun Œº =>
      (eigenspace T Œº).subtype‚Çó·µ¢ :=
  hT.orthogonalFamily_eigenspaces.comp Subtype.coe_injective
#align linear_map.is_symmetric.orthogonal_family_eigenspaces' LinearMap.IsSymmetric.orthogonalFamily_eigenspaces'

/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner
product space is an invariant subspace of the operator. -/
theorem orthogonalComplement_iSup_eigenspaces_invariant ‚¶Év : E‚¶Ñ (hv : v ‚àà (‚®Ü Œº, eigenspace T Œº)·óÆ) :
    T v ‚àà (‚®Ü Œº, eigenspace T Œº)·óÆ := by
  rw [‚Üê Submodule.iInf_orthogonal] at hv ‚ä¢
  exact T.iInf_invariant hT.invariant_orthogonalComplement_eigenspace v hv
#align linear_map.is_symmetric.orthogonal_supr_eigenspaces_invariant LinearMap.IsSymmetric.orthogonalComplement_iSup_eigenspaces_invariant

/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner
product space has no eigenvalues. -/
theorem orthogonalComplement_iSup_eigenspaces (Œº : ùïú) :
    eigenspace (T.restrict hT.orthogonalComplement_iSup_eigenspaces_invariant) Œº = ‚ä• := by
  set p : Submodule ùïú E := (‚®Ü Œº, eigenspace T Œº)·óÆ
  refine eigenspace_restrict_eq_bot hT.orthogonalComplement_iSup_eigenspaces_invariant ?_
  have H‚ÇÇ : eigenspace T Œº ‚üÇ p := (Submodule.isOrtho_orthogonal_right _).mono_left (le_iSup _ _)
  exact H‚ÇÇ.disjoint
#align linear_map.is_symmetric.orthogonal_supr_eigenspaces LinearMap.IsSymmetric.orthogonalComplement_iSup_eigenspaces

/-! ### Finite-dimensional theory -/


variable [FiniteDimensional ùïú E]

/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a
finite-dimensional inner product space is trivial. -/
theorem orthogonalComplement_iSup_eigenspaces_eq_bot : (‚®Ü Œº, eigenspace T Œº)·óÆ = ‚ä• := by
  have hT' : IsSymmetric _ :=
    hT.restrict_invariant hT.orthogonalComplement_iSup_eigenspaces_invariant
  -- a self-adjoint operator on a nontrivial inner product space has an eigenvalue
  haveI :=
    hT'.subsingleton_of_no_eigenvalue_finiteDimensional hT.orthogonalComplement_iSup_eigenspaces
  exact Submodule.eq_bot_of_subsingleton
#align linear_map.is_symmetric.orthogonal_supr_eigenspaces_eq_bot LinearMap.IsSymmetric.orthogonalComplement_iSup_eigenspaces_eq_bot

theorem orthogonalComplement_iSup_eigenspaces_eq_bot' :
    (‚®Ü Œº : Eigenvalues T, eigenspace T Œº)·óÆ = ‚ä• :=
  show (‚®Ü Œº : { Œº // eigenspace T Œº ‚â† ‚ä• }, eigenspace T Œº)·óÆ = ‚ä• by
    rw [iSup_ne_bot_subtype, hT.orthogonalComplement_iSup_eigenspaces_eq_bot]
#align linear_map.is_symmetric.orthogonal_supr_eigenspaces_eq_bot' LinearMap.IsSymmetric.orthogonalComplement_iSup_eigenspaces_eq_bot'

/-- The eigenspaces of a self-adjoint operator on a finite-dimensional inner product space `E` gives
an internal direct sum decomposition of `E`.

Note this takes `hT` as a `Fact` to allow it to be an instance. -/
noncomputable instance directSumDecomposition [hT : Fact T.IsSymmetric] :
    DirectSum.Decomposition fun Œº : Eigenvalues T => eigenspace T Œº :=
  haveI h : ‚àÄ Œº : Eigenvalues T, CompleteSpace (eigenspace T Œº) := fun Œº => by infer_instance
  hT.out.orthogonalFamily_eigenspaces'.decomposition
    (Submodule.orthogonal_eq_bot_iff.mp hT.out.orthogonalComplement_iSup_eigenspaces_eq_bot')
#align linear_map.is_symmetric.direct_sum_decomposition LinearMap.IsSymmetric.directSumDecomposition

theorem directSum_decompose_apply [_hT : Fact T.IsSymmetric] (x : E) (Œº : Eigenvalues T) :
    DirectSum.decompose (fun Œº : Eigenvalues T => eigenspace T Œº) x Œº =
      orthogonalProjection (eigenspace T Œº) x :=
  rfl
#align linear_map.is_symmetric.direct_sum_decompose_apply LinearMap.IsSymmetric.directSum_decompose_apply

/-- The eigenspaces of a self-adjoint operator on a finite-dimensional inner product space `E` gives
an internal direct sum decomposition of `E`. -/
theorem direct_sum_isInternal : DirectSum.IsInternal fun Œº : Eigenvalues T => eigenspace T Œº :=
  hT.orthogonalFamily_eigenspaces'.isInternal_iff.mpr
    hT.orthogonalComplement_iSup_eigenspaces_eq_bot'
#align linear_map.is_symmetric.direct_sum_is_internal LinearMap.IsSymmetric.direct_sum_isInternal

section Version1

/-- Isometry from an inner product space `E` to the direct sum of the eigenspaces of some
self-adjoint operator `T` on `E`. -/
noncomputable def diagonalization : E ‚âÉ‚Çó·µ¢[ùïú] PiLp 2 fun Œº : Eigenvalues T => eigenspace T Œº :=
  hT.direct_sum_isInternal.isometryL2OfOrthogonalFamily hT.orthogonalFamily_eigenspaces'
#align linear_map.is_symmetric.diagonalization LinearMap.IsSymmetric.diagonalization

@[simp]
theorem diagonalization_symm_apply (w : PiLp 2 fun Œº : Eigenvalues T => eigenspace T Œº) :
    hT.diagonalization.symm w = ‚àë Œº, w Œº :=
  hT.direct_sum_isInternal.isometryL2OfOrthogonalFamily_symm_apply
    hT.orthogonalFamily_eigenspaces' w
#align linear_map.is_symmetric.diagonalization_symm_apply LinearMap.IsSymmetric.diagonalization_symm_apply

/-- *Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a
finite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the
direct sum of the eigenspaces of `T`. -/
theorem diagonalization_apply_self_apply (v : E) (Œº : Eigenvalues T) :
    hT.diagonalization (T v) Œº = (Œº : ùïú) ‚Ä¢ hT.diagonalization v Œº := by
  suffices
    ‚àÄ w : PiLp 2 fun Œº : Eigenvalues T => eigenspace T Œº,
      T (hT.diagonalization.symm w) = hT.diagonalization.symm fun Œº => (Œº : ùïú) ‚Ä¢ w Œº by
    simpa only [LinearIsometryEquiv.symm_apply_apply, LinearIsometryEquiv.apply_symm_apply] using
      congr_arg (fun w => hT.diagonalization w Œº) (this (hT.diagonalization v))
  intro w
  have hwT : ‚àÄ Œº, T (w Œº) = (Œº : ùïú) ‚Ä¢ w Œº := fun Œº => mem_eigenspace_iff.1 (w Œº).2
  simp only [hwT, diagonalization_symm_apply, map_sum, Submodule.coe_smul_of_tower]
#align linear_map.is_symmetric.diagonalization_apply_self_apply LinearMap.IsSymmetric.diagonalization_apply_self_apply

end Version1

section Version2

variable {n : ‚Ñï} (hn : FiniteDimensional.finrank ùïú E = n)

/-- A choice of orthonormal basis of eigenvectors for self-adjoint operator `T` on a
finite-dimensional inner product space `E`.

TODO Postcompose with a permutation so that these eigenvectors are listed in increasing order of
eigenvalue. -/
noncomputable irreducible_def eigenvectorBasis : OrthonormalBasis (Fin n) ùïú E :=
  hT.direct_sum_isInternal.subordinateOrthonormalBasis hn hT.orthogonalFamily_eigenspaces'
#align linear_map.is_symmetric.eigenvector_basis LinearMap.IsSymmetric.eigenvectorBasis

/-- The sequence of real eigenvalues associated to the standard orthonormal basis of eigenvectors
for a self-adjoint operator `T` on `E`.

TODO Postcompose with a permutation so that these eigenvalues are listed in increasing order. -/
noncomputable irreducible_def eigenvalues (i : Fin n) : ‚Ñù :=
  @RCLike.re ùïú _ <| (hT.direct_sum_isInternal.subordinateOrthonormalBasisIndex hn i
    hT.orthogonalFamily_eigenspaces').val
#align linear_map.is_symmetric.eigenvalues LinearMap.IsSymmetric.eigenvalues

theorem hasEigenvector_eigenvectorBasis (i : Fin n) :
    HasEigenvector T (hT.eigenvalues hn i) (hT.eigenvectorBasis hn i) := by
  let v : E := hT.eigenvectorBasis hn i
  let Œº : ùïú :=
    (hT.direct_sum_isInternal.subordinateOrthonormalBasisIndex hn i
      hT.orthogonalFamily_eigenspaces').val
  simp_rw [eigenvalues]
  change HasEigenvector T (RCLike.re Œº) v
  have key : HasEigenvector T Œº v := by
    have H‚ÇÅ : v ‚àà eigenspace T Œº := by
      simp_rw [v, eigenvectorBasis]
      exact
        hT.direct_sum_isInternal.subordinateOrthonormalBasis_subordinate hn i
          hT.orthogonalFamily_eigenspaces'
    have H‚ÇÇ : v ‚â† 0 := by simpa using (hT.eigenvectorBasis hn).toBasis.ne_zero i
    exact ‚ü®H‚ÇÅ, H‚ÇÇ‚ü©
  have re_Œº : ‚Üë(RCLike.re Œº) = Œº := by
    rw [‚Üê RCLike.conj_eq_iff_re]
    exact hT.conj_eigenvalue_eq_self (hasEigenvalue_of_hasEigenvector key)
  simpa [re_Œº] using key
#align linear_map.is_symmetric.has_eigenvector_eigenvector_basis LinearMap.IsSymmetric.hasEigenvector_eigenvectorBasis

theorem hasEigenvalue_eigenvalues (i : Fin n) : HasEigenvalue T (hT.eigenvalues hn i) :=
  Module.End.hasEigenvalue_of_hasEigenvector (hT.hasEigenvector_eigenvectorBasis hn i)
#align linear_map.is_symmetric.has_eigenvalue_eigenvalues LinearMap.IsSymmetric.hasEigenvalue_eigenvalues

@[simp]
theorem apply_eigenvectorBasis (i : Fin n) :
    T (hT.eigenvectorBasis hn i) = (hT.eigenvalues hn i : ùïú) ‚Ä¢ hT.eigenvectorBasis hn i :=
  mem_eigenspace_iff.mp (hT.hasEigenvector_eigenvectorBasis hn i).1
#align linear_map.is_symmetric.apply_eigenvector_basis LinearMap.IsSymmetric.apply_eigenvectorBasis

/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a
finite-dimensional inner product space `E` acts diagonally on the identification of `E` with
Euclidean space induced by an orthonormal basis of eigenvectors of `T`. -/
theorem eigenvectorBasis_apply_self_apply (v : E) (i : Fin n) :
    (hT.eigenvectorBasis hn).repr (T v) i =
      hT.eigenvalues hn i * (hT.eigenvectorBasis hn).repr v i := by
  suffices
    ‚àÄ w : EuclideanSpace ùïú (Fin n),
      T ((hT.eigenvectorBasis hn).repr.symm w) =
        (hT.eigenvectorBasis hn).repr.symm fun i => hT.eigenvalues hn i * w i by
    simpa [OrthonormalBasis.sum_repr_symm] using
      congr_arg (fun v => (hT.eigenvectorBasis hn).repr v i)
        (this ((hT.eigenvectorBasis hn).repr v))
  intro w
  simp_rw [‚Üê OrthonormalBasis.sum_repr_symm, map_sum, map_smul, apply_eigenvectorBasis]
  apply Fintype.sum_congr
  intro a
  rw [smul_smul, mul_comm]
#align linear_map.is_symmetric.diagonalization_basis_apply_self_apply LinearMap.IsSymmetric.eigenvectorBasis_apply_self_apply

end Version2

section Simultaneous

variable {A B : E ‚Üí‚Çó[ùïú] E}  {Œ± Œ≤ : ùïú} (hA : A.IsSymmetric) (hB : B.IsSymmetric)
     [FiniteDimensional ùïú E] (hAB : A ‚àò‚Çó B = B ‚àò‚Çó A)

theorem eigenspace_invariant  (Œ± : ùïú) : ‚àÄ v ‚àà (eigenspace A Œ±), (B v ‚àà eigenspace A Œ±) := by
  intro v hv
  rw [eigenspace, mem_ker, sub_apply, Module.algebraMap_end_apply, ‚Üê comp_apply A B v, hAB,
  comp_apply B A v, ‚Üê map_smul, ‚Üê map_sub, hv, map_zero] at *

theorem iSup_restrict_eq_top: (‚®Ü Œ≥ , (eigenspace (LinearMap.restrict B
    (eigenspace_invariant hAB Œ±)) Œ≥)) = ‚ä§ := by
    rw [‚Üê Submodule.orthogonal_eq_bot_iff]
    exact orthogonalComplement_iSup_eigenspaces_eq_bot (LinearMap.IsSymmetric.restrict_invariant hB
    (eigenspace_invariant hAB Œ±))

theorem eigen_extend (Œ≥ : ùïú) (x : E) : x ‚àà Submodule.map (Submodule.subtype (eigenspace A Œ±))
    (eigenspace (B.restrict (eigenspace_invariant hAB Œ±)) Œ≥) ‚Üí x ‚àà eigenspace B Œ≥ := by
  simp only [mem_ker, sub_apply, Module.algebraMap_end_apply, Submodule.mem_map, mem_ker, sub_apply,
  Module.algebraMap_end_apply, Submodule.coeSubtype, Subtype.exists, SetLike.mk_smul_mk,
  exists_and_right, exists_eq_right] at *
  intro ‚ü®y, hy‚ü©
  exact (AddSubmonoid.mk_eq_zero (ker (A -
    (algebraMap ùïú (Module.End ùïú E)) Œ±)).toAddSubgroup.toAddSubmonoid).mp hy

theorem restrict_eq_inf : (fun (Œ≥ : ùïú) ‚Ü¶
    Submodule.map (Submodule.subtype (eigenspace A Œ±)) (eigenspace (B.restrict
    (eigenspace_invariant hAB Œ±)) Œ≥)) = (fun (Œ≥ : ùïú) ‚Ü¶ (eigenspace B Œ≥ ‚äì eigenspace A Œ±)) := by
  funext Œ≥
  ext x
  simp only [Submodule.mem_map, Submodule.coeSubtype, Subtype.exists, exists_and_right,
      exists_eq_right] at *
  constructor
  <;> intro ‚ü®x1, x2‚ü©
  ¬∑ constructor
    <;> rw [SetLike.mem_coe]
    ¬∑ apply eigen_extend hAB Œ≥ x
      simp only [Submodule.mem_map, Submodule.coeSubtype, Subtype.exists, exists_and_right,
        exists_eq_right]
      use x1
    ¬∑ exact x1
  ¬∑ use x2
    refine mem_eigenspace_iff.mpr ?h.a
    refine SetCoe.ext ?h.a.a
    rw [restrict_coe_apply]
    exact mem_eigenspace_iff.mp x1

theorem semi_final_exhaust : (‚®Ü (Œ≥ : ùïú), (eigenspace B Œ≥ ‚äì eigenspace A Œ±)) = eigenspace A Œ± := by
   rw [‚Üê restrict_eq_inf hAB, ‚Üê Submodule.map_iSup, iSup_restrict_eq_top hB hAB,
   Submodule.map_top, Submodule.range_subtype]

theorem pre_exhaust :  (‚®Ü (Œ≥ : ùïú), eigenspace A Œ≥) =  ‚ä§ := by
  exact Submodule.orthogonal_eq_bot_iff.mp (hA.orthogonalComplement_iSup_eigenspaces_eq_bot)

theorem pre_exhaust': (fun (Œ± : ùïú) ‚Ü¶  eigenspace A Œ±)  = fun (Œ± : ùïú) ‚Ü¶
    (‚®Ü (Œ≥ : ùïú), (eigenspace B Œ≥ ‚äì eigenspace A Œ±)) := by
  funext; exact (semi_final_exhaust hB hAB).symm

theorem exhaust : (‚®Ü (Œ± : ùïú), (‚®Ü (Œ≥ : ùïú), (eigenspace B Œ≥ ‚äì eigenspace A Œ±))) = ‚ä§ := by
  rw [‚Üê pre_exhaust hA, pre_exhaust' hB hAB]

theorem post_exhaust: (‚®Ü (Œ± : ùïú), (‚®Ü (Œ≥ : ùïú), (eigenspace B Œ≥ ‚äì eigenspace A Œ±)))·óÆ = ‚ä• := by
  rw [Submodule.orthogonal_eq_bot_iff]
  apply exhaust hA hB hAB

theorem Orthogonality : OrthogonalFamily ùïú (fun (i : ùïú √ó ùïú) =>
    (eigenspace B i.1 ‚äì eigenspace A i.2 : Submodule ùïú E))
    (fun i => (eigenspace B i.1 ‚äì eigenspace A i.2).subtype‚Çó·µ¢) := by
  apply orthogonalFamily_iff_pairwise.mpr ?_
  intro i j hij v hv
  have e:= (Iff.not (Iff.symm Prod.ext_iff)).mpr hij
  push_neg at e
  by_cases case : i.1 = j.1
  ¬∑ have J := e case
    have Al := orthogonalFamily_iff_pairwise.mp hA.orthogonalFamily_eigenspaces J
    rw[@Submodule.mem_orthogonal']
    intro w hw
    simp only [Submodule.mem_inf] at hw
    have L := hv.2
    have M := hw.2
    exact inner_eq_zero_symm.mp (Al L w M)
  ¬∑ push_neg at case
    rw[@Submodule.mem_orthogonal']
    intro w hw
    simp only [Submodule.mem_inf] at hw
    have L := hv.1
    have M := hw.1
    have Bl := orthogonalFamily_iff_pairwise.mp hB.orthogonalFamily_eigenspaces case
    exact inner_eq_zero_symm.mp (Bl L w M)

theorem post_post_exhaust: DirectSum.IsInternal
    (fun (i : ùïú √ó ùïú) ‚Ü¶ (eigenspace B i.1 ‚äì eigenspace A i.2)):= by
  have One := Orthogonality hA hB
  have Two : ‚®Ü (Œ± : ùïú), (‚®Ü (Œ≥ : ùïú), (eigenspace B Œ≥ ‚äì eigenspace A Œ±)) =
      ‚®Ü (i : ùïú √ó ùïú), (eigenspace B i.1 ‚äì eigenspace A i.2) := by
    simp only [iSup_prod]
    exact iSup_comm
  have Three : ‚®Ü (i : ùïú √ó ùïú), (eigenspace B i.1 ‚äì eigenspace A i.2) = ‚ä§ := by
    rw [‚Üê Two]
    exact exhaust hA hB hAB
  have Four : (‚®Ü (i : ùïú √ó ùïú), (eigenspace B i.1 ‚äì eigenspace A i.2))·óÆ = ‚ä• := by
    simp only [Submodule.orthogonal_eq_bot_iff, Three]
  exact (OrthogonalFamily.isInternal_iff One).mpr Four

universe u

variable {n m : Type u} [Fintype n] [Fintype m] (T : n ‚Üí (E ‚Üí‚Çó[ùïú] E))
    (hT :(‚àÄ (i : n), ((T i).IsSymmetric)))
    (hC : (‚àÄ (i j : n), (T i) ‚àò‚Çó (T j) = (T j) ‚àò‚Çó (T i)))

open Classical

theorem eigenspace_of_subsingleton_nonempty [Subsingleton n] (h : Nonempty n) :
    ‚àÉ (S : E ‚Üí‚Çó[ùïú] E), S.IsSymmetric ‚àß (‚àÄ (Œ≥ : n ‚Üí ùïú), (‚àÄ (i : n),
    (eigenspace (T i) (Œ≥ i) = eigenspace S (Œ≥ i)))) := by
  have h0 : ‚àÉ (S : E ‚Üí‚Çó[ùïú] E), S.IsSymmetric ‚àß (‚àÄ (i : n), T i = S) := by
    have i := choice h
    have H : (‚àÄ (i j : n), T j  = T i) := by
      intro i _ ; rw [Subsingleton.allEq i _]
    use (T i)
    constructor
    ¬∑ exact hT i
    ¬∑ exact fun i_1 ‚Ü¶ H i i_1
  obtain ‚ü®S , hS‚ü© := h0
  use S
  constructor
  ¬∑ exact hS.1
  ¬∑ have h1 : (‚àÄ (i : n), T i = S) ‚Üí (‚àÄ (Œ≥ : n ‚Üí ùïú), (‚àÄ (i : n),
    (eigenspace (T i) (Œ≥ i) = eigenspace S (Œ≥ i)))) :=
     fun a Œ≥ i ‚Ü¶ congrFun (congrArg eigenspace (a i)) (Œ≥ i)
    exact h1 hS.2

/-This has been moved via PR #14833-/
theorem eq_iff_orthogonalComplement_eq {K L : Submodule ùïú E} : K = L ‚Üî K·óÆ = L·óÆ := by
   constructor
   ¬∑ exact fun a ‚Ü¶ congrArg Submodule.orthogonal a
   ¬∑ intro H
     rw [‚Üê (Submodule.orthogonal_orthogonal K), ‚Üê (Submodule.orthogonal_orthogonal) L]
     exact congrArg Submodule.orthogonal H

/--The following result is auxiliary, and not meant to be used outside this file. It forms
the base case of the induction proof of `orthogonalComplement_iSup_iInf_eigenspaces_eq_bot`-/
theorem orthogonalComplement_iSup_iInf_eigenspaces_eq_bot_base [Subsingleton n]:
    (‚®Ü (Œ≥ : n ‚Üí ùïú), (‚®Ö (j : n), (eigenspace (T j) (Œ≥ j)) : Submodule ùïú E))·óÆ = ‚ä• := by
  by_cases case : Nonempty n
  ¬∑ obtain ‚ü®S, hS‚ü© := eigenspace_of_subsingleton_nonempty T hT case
    have h1 : (‚®Ü (Œ≥ : n ‚Üí ùïú), (‚®Ö (j : n), (eigenspace S (Œ≥ j)) : Submodule ùïú E))
        = (‚®Ü t, eigenspace S t) := by
      have h2 : ‚àÄ (K : Submodule ùïú E), ((‚àÄ (a : n ‚Üí ùïú), ‚®Ö j, eigenspace S (a j) ‚â§ K) ‚Üî
        (‚àÄ (b : ùïú), eigenspace S b ‚â§ K)) := by
        intro K
        constructor
        ¬∑ intro H b
          have := H (Function.const n b)
          simpa only [ge_iff_le, Function.const_apply, ciInf_const]
        ¬∑ intro h f
          have c := choice case
          have A := eq_const_of_subsingleton f c; have := h (f c); rw [A]
          simpa only [Function.const_apply, ciInf_const, ge_iff_le]
      ext F
      simp only [iSup, sSup, Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff,
          Submodule.mem_mk, AddSubmonoid.mem_mk, AddSubsemigroup.mem_mk, Set.mem_iInter,
          SetLike.mem_coe] at *
      constructor
      ¬∑ intro hF i hi
        have I : ‚àÄ (a : ùïú), eigenspace S a ‚â§ i := fun a ‚Ü¶ hi a
        rw [‚Üê h2] at I; apply hF; exact I
      ¬∑ intro hF i hi
        have I : ‚àÄ (a : n ‚Üí ùïú), ‚®Ö j, eigenspace S (a j) ‚â§ i := fun a ‚Ü¶ hi fun j ‚Ü¶ a j
        rw [h2] at I; apply hF; exact I
    simp only [hS]
    rw [‚Üê orthogonalComplement_iSup_eigenspaces_eq_bot hS.1]
    apply eq_iff_orthogonalComplement_eq.mpr
    simp only [Submodule.orthogonal_orthogonal, Submodule.mk.injEq, AddSubmonoid.mk.injEq,
      AddSubsemigroup.mk.injEq]; exact h1
  ¬∑ simp only [not_nonempty_iff] at case
    simp only [iInf_of_empty, ciSup_unique, Submodule.top_orthogonal_eq_bot]

theorem invariance_iInf [Nonempty n] {S : E ‚Üí‚Çó[ùïú] E} (h : ‚àÄ (i : n), (T i) ‚àò‚Çó S = S ‚àò‚Çó (T i)) :
    ‚àÄ Œ≥ : n ‚Üí ùïú, ‚àÄ v ‚àà (‚®Ö (i : n), eigenspace (T i) (Œ≥ i)),
    S v ‚àà (‚®Ö (i : n), eigenspace (T i) (Œ≥ i)) := by
  intro Œ≥ v hv
  simp only [Submodule.mem_iInf] at *
  intro i
  exact eigenspace_invariant (h i) (Œ≥ i) v (hv i)

theorem invariance_iInf' [Nonempty n] (i : n) :
    ‚àÄ Œ≥ : {x // i ‚â† x} ‚Üí ùïú, ‚àÄ v ‚àà (‚®Ö (j : {x // i ‚â† x}), eigenspace ((Subtype.restrict (fun x ‚Ü¶ i ‚â† x) T) j) (Œ≥ j)),
    (T i) v ‚àà (‚®Ö (j : {x // i ‚â† x}), eigenspace ((Subtype.restrict (fun x ‚Ü¶ i ‚â† x) T) j) (Œ≥ j)) := by
  intro Œ≥ v hv
  simp only [Submodule.mem_iInf] at *
  exact fun i_1 ‚Ü¶ eigenspace_invariant (hC (‚Üëi_1) i) (Œ≥ i_1) v (hv i_1)

theorem invariance_iInf'' [Nonempty n] (i : n) :
    ‚àÄ Œ≥ : n ‚Üí ùïú, ‚àÄ v ‚àà (‚®Ö (j : n), eigenspace (T j) (Œ≥ j)),
    (T i) v ‚àà (‚®Ö (j : n), eigenspace (T j) (Œ≥ j)) := by
  intro Œ≥ v hv
  simp only [Submodule.mem_iInf] at *
  exact fun i_1 ‚Ü¶ eigenspace_invariant (hC i_1 i) (Œ≥ i_1) v (hv i_1)

theorem inf_restrict' [Nonempty n] (i : n) (Œ≥ : {x // i ‚â† x} ‚Üí ùïú) :
    (‚®Ü (Œº : ùïú) , eigenspace ((T i).restrict
    ((invariance_iInf' T hC i Œ≥))) Œº)·óÆ = ‚ä• := by
  exact (LinearMap.IsSymmetric.restrict_invariant (hT i)
    (invariance_iInf' T hC i Œ≥)).orthogonalComplement_iSup_eigenspaces_eq_bot

@[simp]
theorem inf_restrict'' [Nonempty n] (i : n) (Œ≥ : {x // i ‚â† x} ‚Üí ùïú) :
    (‚®Ü (Œº : ùïú) , eigenspace ((T i).restrict
    ((invariance_iInf' T hC i Œ≥))) Œº) = ‚ä§ := by
  exact
    pre_exhaust fun x y ‚Ü¶
      hT i ((‚®Ö j, eigenspace (Subtype.restrict (fun x ‚Ü¶ i ‚â† x) T j) (Œ≥ j)).subtype x) ‚Üëy

theorem inf_restrict''' [Nonempty n] (i : n) (Œ≥ : {x // i ‚â† x} ‚Üí ùïú) :
    Submodule.map (Submodule.subtype (‚®Ö j, eigenspace (Subtype.restrict
    (fun x ‚Ü¶ i ‚â† x) T j) (Œ≥ j))) (‚®Ü (Œº : ùïú) , eigenspace ((T i).restrict
    ((invariance_iInf' T hC i Œ≥))) Œº) = Submodule.map (Submodule.subtype (‚®Ö j, eigenspace
    (Subtype.restrict (fun x ‚Ü¶ i ‚â† x) T j) (Œ≥ j))) ‚ä§ := by
  congr!
  congr!
  exact inf_restrict'' T hT hC i fun j ‚Ü¶ Œ≥ j

theorem index_convert (i : n) [Nonempty n] (Œº : ùïú) (Œ≥ : {x // i ‚â† x} ‚Üí ùïú) : (eigenspace (T i) Œº ‚äì
    (‚®Ö (j : {x // i ‚â† x}), eigenspace (Subtype.restrict (fun x ‚Ü¶ i ‚â† x) T j) (Œ≥ j))) =
    Submodule.map (Submodule.subtype ((‚®Ö (j : {x // i ‚â† x}), eigenspace (T j) (Œ≥ j))))
    (eigenspace ((T i).restrict ((invariance_iInf' T hC i Œ≥))) Œº) := by
  ext v
  constructor
  ¬∑ intro h
    simp only [ne_eq, Submodule.mem_inf, Submodule.mem_iInf, Subtype.forall] at h
    obtain ‚ü®A, B‚ü© := h
    simp only [ne_eq, Submodule.mem_map, Subtype.exists, Submodule.mem_iInf, Subtype.forall]
    use v
    use B
    constructor
    ¬∑ ext
      simp only [sub_apply, Module.algebraMap_end_apply, SetLike.mk_smul_mk,
        AddSubgroupClass.coe_sub, restrict_coe_apply, ZeroMemClass.coe_zero]
      exact A
    ¬∑ rfl
  ¬∑ intro h
    constructor
    ¬∑ simp only [ne_eq, Submodule.mem_map, Subtype.exists, Submodule.mem_iInf, Subtype.forall] at h
      obtain ‚ü®w, hw, A, B‚ü© := h
      simp only [SetLike.mem_coe, eigenspace, mem_ker, sub_apply, Module.algebraMap_end_apply]
      simp only [eigenspace, mem_ker, sub_apply, Module.algebraMap_end_apply, SetLike.mk_smul_mk] at A
      rw [‚Üê B]
      exact
        (AddSubmonoid.mk_eq_zero
              (‚®Ö j,
                    ker
                      (Subtype.restrict (fun x ‚Ü¶ ¬¨i = x) T j -
                        (algebraMap ùïú (Module.End ùïú E)) (Œ≥ j))).toAddSubgroup.toAddSubmonoid).mp
          A
    ¬∑ simp only [ne_eq, Submodule.iInf_coe, Set.mem_iInter, SetLike.mem_coe, Subtype.forall]
      intro j hj
      simp only [eigenspace, mem_ker, sub_apply, Module.algebraMap_end_apply] at *
      simp only [ne_eq, Submodule.mem_map, mem_ker, sub_apply, Module.algebraMap_end_apply,
        Subtype.exists, SetLike.mk_smul_mk, Submodule.mem_iInf, Subtype.forall] at h
      obtain ‚ü®w, hw, _, B‚ü© := h
      rw [‚Üê B]
      exact hw j hj

theorem index_eigen_extend (i : n) [Nonempty n] (Œ≥ : {x // i ‚â† x} ‚Üí ùïú) (Œº : ùïú) (x : E) :
    x ‚àà Submodule.map (Submodule.subtype (‚®Ö (j: {x // i ‚â† x}), eigenspace (T ‚Üëj) (Œ≥ j)))
    (eigenspace ((T i).restrict ((invariance_iInf' T hC i Œ≥))) Œº) ‚Üí
    x ‚àà (‚®Ö (j : {x // i ‚â† x}), eigenspace (Subtype.restrict (fun x ‚Ü¶ i ‚â† x) T j) (Œ≥ j)) := by
  intro h
  simp only [ne_eq, Submodule.mem_map, Subtype.exists, Submodule.mem_iInf, Subtype.forall] at *
  intro a b
  obtain ‚ü®a', ‚ü®ha, ‚ü®_, h2‚ü©‚ü©‚ü© := h
  rw [‚Üê h2]
  exact ha a b

theorem ext_experiment (i : n) [Nonempty n] (Œ≥ : {x // i ‚â† x} ‚Üí ùïú) : ‚àÄ x,
    x ‚àà (‚®Ü (Œº : ùïú) , eigenspace ((T i).restrict ((invariance_iInf' T hC i Œ≥))) Œº) ‚Üî
    x ‚àà (‚ä§ : Submodule ùïú ‚Ü•(‚®Ö j, eigenspace (Subtype.restrict (fun x ‚Ü¶ i ‚â† x) T j) (Œ≥ j))) := by
  have H := inf_restrict'' T hT hC i Œ≥
  simp only [ne_eq, H, Submodule.mem_top, implies_true]

@[simp]
theorem ultra_silly_lemma (i : n) [Nonempty n] (Œ≥ : {x // i ‚â† x} ‚Üí ùïú) :
    (‚®Ö (j : {x // i ‚â† x}), eigenspace (Subtype.restrict (fun x ‚Ü¶ i ‚â† x) T j) (Œ≥ j)) =
    (‚®Ö (j : {x // i ‚â† x}), eigenspace (T j) (Œ≥ j)) := rfl

theorem indexing_nonsense0 (i : n) [Nontrivial n] (Œ≥ : n ‚Üí ùïú) :
     ‚®Ö (j : n), eigenspace (T j) (Œ≥ j) = (eigenspace (T i) (Œ≥ i)) ‚äì
     ‚®Ö (j : {x // i ‚â† x}), eigenspace (T j) (Œ≥ j) := by
  ext v
  constructor
  ¬∑ intro h
    constructor
    ¬∑ simp [iInf, sInf] at h
      exact h i
    ¬∑ simp [iInf, sInf] at *
      exact fun i_1 _ ‚Ü¶ h i_1
  ¬∑ intro h
    simp [iInf, sInf]
    intro k
    by_cases H : k = i
    ¬∑ rw [H]
      exact h.1
    ¬∑ have F := h.2
      simp only [ne_eq, Submodule.iInf_coe, Set.mem_iInter, SetLike.mem_coe, Subtype.forall] at F
      exact F k fun a ‚Ü¶ H (_root_.id (Eq.symm a))


theorem indexing_nonsense (i : n) [Nontrivial n] : ‚®Ü (Œ≥ : n ‚Üí ùïú), ‚®Ö j : n, eigenspace (T j) (Œ≥ j)
    = (‚®Ü (Œ≥ : {x // i ‚â† x} ‚Üí ùïú), (‚®Ü Œº : ùïú, (eigenspace (T i) Œº ‚äì
    (‚®Ö (j : {x // i ‚â† x}), eigenspace (Subtype.restrict (fun x ‚Ü¶ i ‚â† x) T j) (Œ≥ j))))) := by
  ext v
  constructor
  ¬∑ intro h
    simp only [ne_eq, ultra_silly_lemma]
    conv =>
     rhs
     rw [iSup]
    simp only [sSup, Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff, iSup_le_iff,
      Submodule.mem_mk, AddSubmonoid.mem_mk, AddSubsemigroup.mem_mk, Set.mem_iInter,
      SetLike.mem_coe]
    intro K
    rw [iSup] at h
    simp only [sSup, Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff, Submodule.mem_mk,
      AddSubmonoid.mem_mk, AddSubsemigroup.mem_mk, Set.mem_iInter, SetLike.mem_coe] at h
    intro H
    apply h K
    intro a w hw
    rw [indexing_nonsense0 T (i := i) (Œ≥ := a)] at hw
    simp only [ne_eq, Submodule.mem_inf] at hw
    have : ‚àÄ (a : n ‚Üí ùïú), ‚®Ö j, eigenspace (T j) (a j) ‚â§ K := by
      intro f
      rw [indexing_nonsense0 T i]
      apply H
    exact H (fun j ‚Ü¶ a ‚Üëj) (a i) hw
  ¬∑ intro h
    simp only [ne_eq, ultra_silly_lemma] at h
    rw [iSup] at *
    simp only [sSup, Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff, Submodule.mem_mk,
      AddSubmonoid.mem_mk, AddSubsemigroup.mem_mk, Set.mem_iInter, SetLike.mem_coe] at *
    intro K hK
    have A : ‚àÄ (a : {x // ¬¨i = x} ‚Üí ùïú), ‚®Ü Œº, eigenspace (T i) Œº ‚äì
        ‚®Ö (j : {x // i ‚â† x}), eigenspace (T ‚Üëj) (a j) ‚â§ K := by
      intro Œ≥' v hgv
      simp only [iSup, sSup, ne_eq, Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff,
        Submodule.mem_mk, AddSubmonoid.mem_mk, AddSubsemigroup.mem_mk, Set.mem_iInter,
        SetLike.mem_coe] at hgv
      have B : ‚àÄ (Œº : ùïú), eigenspace (T i) Œº ‚äì ‚®Ö (j : {x // i ‚â† x}), eigenspace (T ‚Üëj) (Œ≥' j) ‚â§ K := by
        intro Œº
        let Œ≥ : n ‚Üí ùïú := Set.piecewise (fun x ‚Ü¶ i ‚â† x) (Function.extend Subtype.val Œ≥' 1)
          (Function.const n Œº)
        have C1 : Œ≥ i = Œº := Set.piecewise_eq_of_not_mem (fun x ‚Ü¶ i ‚â† x) (Function.extend Subtype.val Œ≥' 1)
            (Function.const n Œº) fun a ‚Ü¶ a rfl
        have C2 : ‚àÄ (j : {x // i ‚â† x}), Œ≥ j = Œ≥' j:= by
          intro j
          have := j.2
          simp only [ne_eq, Subtype.coe_prop, Set.piecewise_eq_of_mem, Œ≥]
          refine Function.Injective.extend_apply ?hf Œ≥' _ j
          exact Subtype.val_injective
        have C : eigenspace (T i) Œº ‚äì ‚®Ö (j : {x // i ‚â† x}), eigenspace (T ‚Üëj) (Œ≥' j)
            = eigenspace (T i) (Œ≥ i) ‚äì ‚®Ö (j : {x // i ‚â† x}), eigenspace (T ‚Üëj) (Œ≥ j) := by
          congr!
          exact _root_.id (Eq.symm C1)
          congr!
          simp only [ne_eq, C2]
        rw [C]
        rw [‚Üê indexing_nonsense0]
        exact hK fun j ‚Ü¶ Œ≥ j
      apply hgv
      exact B
    exact h K A

/-This is just index_convert, so we can probably remove later.-/
theorem indexed_matching (i : n) [Nonempty n] (Œ≥ : {x // i ‚â† x} ‚Üí ùïú) (Œº : ùïú) :
   Submodule.map (Submodule.subtype (‚®Ö (j: {x // i ‚â† x}), eigenspace (T ‚Üëj) (Œ≥ j)))
      (eigenspace ((T i).restrict ((invariance_iInf' T hC i Œ≥))) Œº)
       = (eigenspace (T i) Œº ‚äì ‚®Ö j, eigenspace (Subtype.restrict (fun x ‚Ü¶ i ‚â† x) T j) (Œ≥ j)) := by
  rw [‚Üê index_convert T hC i Œº fun j ‚Ü¶ Œ≥ j]

theorem prelim_sub_exhaust (i : n) [Nontrivial n] (Œ≥ : {x // i ‚â† x} ‚Üí ùïú) :
    ‚®Ü Œº, Submodule.map (‚®Ö (j: {x // i ‚â† x}), eigenspace (T ‚Üëj) (Œ≥ j)).subtype
    (eigenspace ((T i).restrict ((invariance_iInf' T hC i Œ≥))) Œº) =
    (‚®Ö (j : {x // i ‚â† x}), eigenspace (Subtype.restrict (fun x ‚Ü¶ i ‚â† x) T j) (Œ≥ j)) := by
  simp only [iSup, sSup, ne_eq, Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff]
  ext v
  constructor
  ¬∑ intro h
    simp only [Submodule.mem_mk, AddSubmonoid.mem_mk, AddSubsemigroup.mem_mk, Set.mem_iInter,
      SetLike.mem_coe] at h
    simp only [iInf, sInf, Set.mem_range, Subtype.exists, Set.iInter_exists, Submodule.mem_mk,
      AddSubmonoid.mem_mk, AddSubsemigroup.mem_mk, Set.mem_iInter, SetLike.mem_coe]
    intro K j hj HH
    apply h
    rw [‚Üê HH]
    intro a w hw
    simp only [iInf, sInf, Submodule.mem_map, Subtype.exists, Set.mem_range, Set.iInter_exists,
      Submodule.mem_mk, AddSubmonoid.mem_mk, AddSubsemigroup.mem_mk, Set.mem_iInter,
      SetLike.mem_coe] at hw
    obtain ‚ü®a, ‚ü®ha, hb‚ü©‚ü© := hw
    rw [‚Üê hb.2]
    exact ha (eigenspace (Subtype.restrict (fun x ‚Ü¶ ¬¨i = x) T ‚ü®j, hj‚ü©) (Œ≥ ‚ü®j, hj‚ü©)) j hj rfl
  ¬∑ have B := inf_restrict''' T hT hC i Œ≥
    simp only [Submodule.mem_iInf, Subtype.forall, Submodule.mem_mk, AddSubmonoid.mem_mk,
      AddSubsemigroup.mem_mk, Set.mem_iInter, SetLike.mem_coe]
    intro h F hH
    have hH1 : ‚àÄ (a : ùïú), Submodule.map (‚®Ö (j : {x // i ‚â† x}) , eigenspace (T ‚Üëj) (Œ≥ j)).subtype
        (eigenspace ((T i).restrict ((invariance_iInf' T hC i Œ≥))) a) ‚â§ F := by exact fun a ‚Ü¶ hH a
    simp only [ne_eq, ultra_silly_lemma, Submodule.map_iSup, Submodule.map_top,
      Submodule.range_subtype] at B
    have RR : (‚®Ü Œº : ùïú, Submodule.map (‚®Ö (j : {x // i ‚â† x}), eigenspace (T ‚Üëj) (Œ≥ j)).subtype
        (eigenspace ((T i).restrict ((invariance_iInf' T hC i Œ≥))) Œº)) ‚â§ F := by
      simp only [ne_eq, ultra_silly_lemma, iSup_le_iff, hH1, implies_true]
    rw [B] at RR
    have Final : v ‚àà ‚®Ö (j: {x // i ‚â† x}), eigenspace (T ‚Üëj) (Œ≥ j) := (Submodule.mem_iInf
      fun (i_1 : {x // i ‚â† x}) ‚Ü¶ eigenspace (T ‚Üëi_1) (Œ≥ i_1)).mpr fun i_1 ‚Ü¶ h (‚Üëi_1) i_1.property
    exact RR Final

theorem index_post_exhaust (i : n) [Nontrivial n] :
    (‚®Ü (Œ≥ : {x // i ‚â† x} ‚Üí ùïú), (‚®Ü Œº : ùïú, (eigenspace (T i) Œº ‚äì (‚®Ö (j : {x // i ‚â† x}),
    eigenspace (Subtype.restrict (fun x ‚Ü¶ i ‚â† x) T j) (Œ≥ j))))) = ‚®Ü (Œ≥ : {x // i ‚â† x} ‚Üí ùïú),
    (‚®Ö (j : {x // i ‚â† x}), eigenspace (Subtype.restrict (fun x ‚Ü¶ i ‚â† x) T j) (Œ≥ j)) := by
  simp only [ne_eq, Submodule.orthogonal_eq_bot_iff]
  conv =>
   lhs
   rhs
   ext Œ≥
   rhs
   ext Œº
   rw [index_convert T hC i]
  conv =>
   lhs
   rhs
   ext Œ≥
   rw [prelim_sub_exhaust T hT hC]

theorem orthogonalComplement_iSup_iInf_eigenspaces_eq_bot:
    (‚®Ü (Œ≥ : n ‚Üí ùïú), (‚®Ö (j : n), (eigenspace (T j) (Œ≥ j)) : Submodule ùïú E))·óÆ = ‚ä• := by
  revert T
  refine' Fintype.induction_subsingleton_or_nontrivial n _ _
  ¬∑ intro m _ hhm T hT _
    exact orthogonalComplement_iSup_iInf_eigenspaces_eq_bot_base T hT
  ¬∑ intro m hm hmm H T hT hC
    obtain ‚ü®i, _ , _ ‚ü© := exists_pair_ne m
    have C : Fintype.card { x // i ‚â† x } < Fintype.card m := by
      simp only [ne_eq, Fintype.card_subtype_compl, Fintype.card_ofSubsingleton,
      tsub_lt_self_iff, zero_lt_one, and_true]
      exact Fintype.card_pos
    have D := H {x // i ‚â† x} C (Subtype.restrict (fun x ‚Ü¶ i ‚â† x) T)
      (fun (i_1 : {x // i ‚â† x}) ‚Ü¶ hT ‚Üëi_1) (fun (i_1 j : { x // i ‚â† x }) ‚Ü¶ hC ‚Üëi_1 ‚Üëj)
    simp only [Submodule.orthogonal_eq_bot_iff] at *
    rw [‚Üê index_post_exhaust] at D
    rw [indexing_nonsense]
    exact D
    exact fun i ‚Ü¶ hT i
    exact hC

theorem orthogonalFamily_iInf_eigenspaces : OrthogonalFamily ùïú (fun (Œ≥ : n ‚Üí ùïú) =>
    (‚®Ö (j : n), (eigenspace (T j) (Œ≥ j)) : Submodule ùïú E))
    (fun (Œ≥ : n ‚Üí ùïú) => (‚®Ö (j : n), (eigenspace (T j) (Œ≥ j))).subtype‚Çó·µ¢) := by
  intro f g hfg Ef Eg
  obtain ‚ü®a , ha‚ü© := Function.ne_iff.mp hfg
  have H := (orthogonalFamily_eigenspaces (hT a) ha)
  simp only [Submodule.coe_subtype‚Çó·µ¢, Submodule.coeSubtype, Subtype.forall] at H
  apply H
  ¬∑ exact (Submodule.mem_iInf <| fun _ ‚Ü¶ eigenspace (T _) (f _)).mp Ef.2 _
  ¬∑ exact (Submodule.mem_iInf <| fun _ ‚Ü¶ eigenspace (T _) (g _)).mp Eg.2 _

/-- The Hilbert space on which a finite commuting family of symmetric linear operators acts
decomposes as an internal direct sum of simultaneous eigenspaces for these operators. -/
theorem direct_sum_isInternal_simultaneous : DirectSum.IsInternal (fun (Œ± : n ‚Üí ùïú) ‚Ü¶
    ‚®Ö (j : n), (eigenspace (T j) (Œ± j))) := by
    rw [OrthogonalFamily.isInternal_iff]
    ¬∑ exact orthogonalComplement_iSup_iInf_eigenspaces_eq_bot T hT hC
    ¬∑ exact orthogonalFamily_iInf_eigenspaces T hT

end Simultaneous

end IsSymmetric

end LinearMap
section Nonneg

@[simp]
theorem inner_product_apply_eigenvector {Œº : ùïú} {v : E} {T : E ‚Üí‚Çó[ùïú] E}
    (h : v ‚àà Module.End.eigenspace T Œº) : ‚ü™v, T v‚ü´ = Œº * (‚Äñv‚Äñ : ùïú) ^ 2 := by
  simp only [mem_eigenspace_iff.mp h, inner_smul_right, inner_self_eq_norm_sq_to_K]
#align inner_product_apply_eigenvector inner_product_apply_eigenvector

theorem eigenvalue_nonneg_of_nonneg {Œº : ‚Ñù} {T : E ‚Üí‚Çó[ùïú] E} (hŒº : HasEigenvalue T Œº)
    (hnn : ‚àÄ x : E, 0 ‚â§ RCLike.re ‚ü™x, T x‚ü´) : 0 ‚â§ Œº := by
  obtain ‚ü®v, hv‚ü© := hŒº.exists_hasEigenvector
  have hpos : (0 : ‚Ñù) < ‚Äñv‚Äñ ^ 2 := by simpa only [sq_pos_iff, norm_ne_zero_iff] using hv.2
  have : RCLike.re ‚ü™v, T v‚ü´ = Œº * ‚Äñv‚Äñ ^ 2 := by
    have := congr_arg RCLike.re (inner_product_apply_eigenvector hv.1)
    -- Porting note: why can't `exact_mod_cast` do this? These lemmas are marked `norm_cast`
    rw [‚Üê RCLike.ofReal_pow, ‚Üê RCLike.ofReal_mul] at this
    exact mod_cast this
  exact (mul_nonneg_iff_of_pos_right hpos).mp (this ‚ñ∏ hnn v)
#align eigenvalue_nonneg_of_nonneg eigenvalue_nonneg_of_nonneg

theorem eigenvalue_pos_of_pos {Œº : ‚Ñù} {T : E ‚Üí‚Çó[ùïú] E} (hŒº : HasEigenvalue T Œº)
    (hnn : ‚àÄ x : E, 0 < RCLike.re ‚ü™x, T x‚ü´) : 0 < Œº := by
  obtain ‚ü®v, hv‚ü© := hŒº.exists_hasEigenvector
  have hpos : (0 : ‚Ñù) < ‚Äñv‚Äñ ^ 2 := by simpa only [sq_pos_iff, norm_ne_zero_iff] using hv.2
  have : RCLike.re ‚ü™v, T v‚ü´ = Œº * ‚Äñv‚Äñ ^ 2 := by
    have := congr_arg RCLike.re (inner_product_apply_eigenvector hv.1)
    -- Porting note: why can't `exact_mod_cast` do this? These lemmas are marked `norm_cast`
    rw [‚Üê RCLike.ofReal_pow, ‚Üê RCLike.ofReal_mul] at this
    exact mod_cast this
  exact (mul_pos_iff_of_pos_right hpos).mp (this ‚ñ∏ hnn v)
#align eigenvalue_pos_of_pos eigenvalue_pos_of_pos


end Nonneg
